#!/bin/bash

# Fix missing types and manager references across FrancoSphere
# Address MaintenanceTask, TaskUrgency, TaskCategory, WeatherManager issues

XCODE_PATH="/Volumes/FastSSD/Xcode"

echo "üîß Fixing missing types and manager references"
echo "==============================================="

cd "$XCODE_PATH" || exit 1

# Step 1: Create missing core types in Models/TaskTypes.swift
echo "üèóÔ∏è Step 1: Creating missing core types..."

cat > "Models/TaskTypes.swift" << 'INNER_EOF'
//
//  TaskTypes.swift
//  FrancoSphere
//
//  ‚úÖ Defines all missing task-related types
//

import Foundation

// MARK: - MaintenanceTask (Core task type)
struct MaintenanceTask: Identifiable, Codable {
    let id: String
    let name: String
    let buildingId: String
    let buildingName: String
    let category: TaskCategory
    let urgency: TaskUrgency
    let recurrence: TaskRecurrence
    let startTime: String
    let endTime: String
    let skillLevel: String
    let status: String
    let assignedWorkerName: String
    let notes: String?
    let estimatedDuration: TimeInterval
    let completedAt: Date?
    
    init(id: String = UUID().uuidString,
         name: String,
         buildingId: String,
         buildingName: String,
         category: TaskCategory,
         urgency: TaskUrgency = .medium,
         recurrence: TaskRecurrence = .daily,
         startTime: String,
         endTime: String,
         skillLevel: String = "Basic",
         status: String = "pending",
         assignedWorkerName: String,
         notes: String? = nil,
         estimatedDuration: TimeInterval = 3600,
         completedAt: Date? = nil) {
        
        self.id = id
        self.name = name
        self.buildingId = buildingId
        self.buildingName = buildingName
        self.category = category
        self.urgency = urgency
        self.recurrence = recurrence
        self.startTime = startTime
        self.endTime = endTime
        self.skillLevel = skillLevel
        self.status = status
        self.assignedWorkerName = assignedWorkerName
        self.notes = notes
        self.estimatedDuration = estimatedDuration
        self.completedAt = completedAt
    }
}

// MARK: - TaskCategory
enum TaskCategory: String, CaseIterable, Codable {
    case cleaning = "Cleaning"
    case sanitation = "Sanitation"
    case maintenance = "Maintenance"
    case inspection = "Inspection"
    case delivery = "Delivery"
    case dsny = "DSNY"
    case emergency = "Emergency"
    case routine = "Routine"
    
    var icon: String {
        switch self {
        case .cleaning: return "üßπ"
        case .sanitation: return "üóëÔ∏è"
        case .maintenance: return "üîß"
        case .inspection: return "üîç"
        case .delivery: return "üì¶"
        case .dsny: return "üöõ"
        case .emergency: return "üö®"
        case .routine: return "üìã"
        }
    }
    
    var color: String {
        switch self {
        case .cleaning: return "blue"
        case .sanitation: return "green"
        case .maintenance: return "orange"
        case .inspection: return "purple"
        case .delivery: return "brown"
        case .dsny: return "yellow"
        case .emergency: return "red"
        case .routine: return "gray"
        }
    }
}

// MARK: - TaskUrgency
enum TaskUrgency: String, CaseIterable, Codable {
    case low = "Low"
    case medium = "Medium"
    case high = "High"
    case critical = "Critical"
    
    var priority: Int {
        switch self {
        case .low: return 1
        case .medium: return 2
        case .high: return 3
        case .critical: return 4
        }
    }
    
    var color: String {
        switch self {
        case .low: return "green"
        case .medium: return "yellow"
        case .high: return "orange"
        case .critical: return "red"
        }
    }
}

// MARK: - TaskRecurrence
enum TaskRecurrence: String, CaseIterable, Codable {
    case daily = "Daily"
    case weekly = "Weekly"
    case biweekly = "Bi-weekly"
    case monthly = "Monthly"
    case quarterly = "Quarterly"
    case yearly = "Yearly"
    case oneOff = "One-off"
    
    var shortForm: String {
        switch self {
        case .daily: return "D"
        case .weekly: return "W"
        case .biweekly: return "BW"
        case .monthly: return "M"
        case .quarterly: return "Q"
        case .yearly: return "Y"
        case .oneOff: return "1x"
        }
    }
}

// MARK: - MaintenanceTask Extensions
extension MaintenanceTask {
    
    // Convert from ContextualTask
    init(from contextualTask: ContextualTask) {
        self.init(
            id: contextualTask.id,
            name: contextualTask.name,
            buildingId: contextualTask.buildingId,
            buildingName: contextualTask.buildingName,
            category: TaskCategory(rawValue: contextualTask.category) ?? .routine,
            urgency: TaskUrgency(rawValue: contextualTask.urgencyLevel) ?? .medium,
            recurrence: TaskRecurrence(rawValue: contextualTask.recurrence) ?? .daily,
            startTime: contextualTask.startTime,
            endTime: contextualTask.endTime,
            skillLevel: contextualTask.skillLevel,
            status: contextualTask.status,
            assignedWorkerName: contextualTask.assignedWorkerName
        )
    }
    
    // Convert to ContextualTask
    func toContextualTask() -> ContextualTask {
        return ContextualTask(
            id: id,
            name: name,
            buildingId: buildingId,
            buildingName: buildingName,
            category: category.rawValue,
            startTime: startTime,
            endTime: endTime,
            recurrence: recurrence.rawValue,
            skillLevel: skillLevel,
            status: status,
            urgencyLevel: urgency.rawValue,
            assignedWorkerName: assignedWorkerName
        )
    }
}
INNER_EOF

echo "   ‚úÖ TaskTypes.swift created with MaintenanceTask, TaskCategory, TaskUrgency, TaskRecurrence"

# Step 2: Create WeatherManager.swift
echo "üå§Ô∏è Step 2: Creating WeatherManager.swift..."

cat > "Managers/WeatherManager.swift" << 'INNER_EOF'
//
//  WeatherManager.swift
//  FrancoSphere
//
//  ‚úÖ Weather management for task scheduling
//

import Foundation
import Combine

@MainActor
class WeatherManager: ObservableObject {
    static let shared = WeatherManager()
    
    @Published var currentWeather: FrancoSphere.WeatherData?
    @Published var isLoading = false
    @Published var error: Error?
    
    private var cancellables = Set<AnyCancellable>()
    private let updateInterval: TimeInterval = 1800 // 30 minutes
    
    private init() {
        startPeriodicUpdates()
    }
    
    func fetchCurrentWeather() async {
        isLoading = true
        error = nil
        
        do {
            // Simulate weather API call for NYC
            let weather = FrancoSphere.WeatherData(
                temperature: Double.random(in: 20...85),
                condition: FrancoSphere.WeatherCondition.allCases.randomElement() ?? .clear,
                humidity: Double.random(in: 30...90),
                windSpeed: Double.random(in: 0...25),
                timestamp: Date()
            )
            
            currentWeather = weather
            isLoading = false
            
        } catch {
            self.error = error
            isLoading = false
        }
    }
    
    func getWeatherImpactForTask(_ task: MaintenanceTask) -> WeatherImpact? {
        guard let weather = currentWeather else { return nil }
        
        // Determine if weather affects this task
        let isOutdoorTask = task.category == .cleaning || 
                           task.category == .sanitation ||
                           task.name.lowercased().contains("sidewalk") ||
                           task.name.lowercased().contains("hose")
        
        guard isOutdoorTask else { return nil }
        
        var impact = WeatherImpact.none
        var recommendation = "Normal conditions for outdoor work."
        
        switch weather.condition {
        case .rain:
            impact = .moderate
            recommendation = "Rain detected. Consider postponing sidewalk hosing and outdoor cleaning."
        case .snow:
            impact = .severe
            recommendation = "Snow conditions. Focus on snow removal and postpone non-essential outdoor tasks."
        default:
            if weather.temperature < 32 {
                impact = .moderate
                recommendation = "Freezing temperatures. Take precautions for outdoor work."
            } else if weather.temperature > 90 {
                impact = .moderate
                recommendation = "High temperature. Take frequent breaks and stay hydrated."
            } else if weather.windSpeed > 20 {
                impact = .mild
                recommendation = "High winds. Secure loose items during outdoor work."
            }
        }
        
        return WeatherImpact(
            level: impact,
            recommendation: recommendation,
            affectedCategories: isOutdoorTask ? [task.category] : []
        )
    }
    
    private func startPeriodicUpdates() {
        Timer.publish(every: updateInterval, on: .main, in: .common)
            .autoconnect()
            .sink { _ in
                Task {
                    await self.fetchCurrentWeather()
                }
            }
            .store(in: &cancellables)
        
        // Initial fetch
        Task {
            await fetchCurrentWeather()
        }
    }
}

// MARK: - Supporting Types

enum WeatherImpact {
    case none
    case mild
    case moderate
    case severe
    
    var color: String {
        switch self {
        case .none: return "green"
        case .mild: return "yellow"
        case .moderate: return "orange"
        case .severe: return "red"
        }
    }
}

struct WeatherImpact {
    let level: WeatherImpact
    let recommendation: String
    let affectedCategories: [TaskCategory]
}
INNER_EOF

echo "   ‚úÖ WeatherManager.swift created"

# Step 3: Fix TaskService.swift to remove TSTaskProgress conflict
echo "üîß Step 3: Fixing TaskService.swift TSTaskProgress conflict..."

if [ -f "Services/TaskService.swift" ]; then
    # Remove the conflicting TSTaskProgress typedef
    sed -i '' '/typealias TSTaskProgress/d' "Services/TaskService.swift"
    sed -i '' '/struct TSTaskProgress/,/^}/d' "Services/TaskService.swift"
    echo "   ‚úÖ Removed TSTaskProgress conflict from TaskService.swift"
fi

# Step 4: Fix WorkerDashboardIntegration.swift (final version)
echo "üîß Step 4: Fixing WorkerDashboardIntegration.swift (final version)..."

cat > "Services/WorkerDashboardIntegration.swift" << 'INNER_EOF'
//
//  WorkerDashboardIntegration.swift
//  FrancoSphere
//
//  ‚úÖ FINAL VERSION - All compilation errors fixed
//

import Foundation
import SwiftUI
import Combine
import CoreLocation

@MainActor
class WorkerDashboardIntegration: ObservableObject {
    
    static let shared = WorkerDashboardIntegration()
    
    // Service Dependencies
    private let taskService = TaskService.shared
    private let workerService = WorkerService.shared
    private let buildingService = BuildingService.shared
    private let contextEngine = WorkerContextEngine.shared
    private let operationalManager = OperationalDataManager.shared
    
    // Published Properties
    @Published var dashboardData: DashboardData?
    @Published var isLoading = false
    @Published var error: Error?
    @Published var csvImportProgress: Double = 0.0
    @Published var lastRefresh: Date?
    
    // Private Properties
    private var refreshTimer: Timer?
    private var cancellables = Set<AnyCancellable>()
    
    private init() {
        setupReactiveBindings()
    }
    
    func loadDashboardData(for workerId: String) async {
        await MainActor.run {
            isLoading = true
            error = nil
        }
        
        do {
            let buildings = try await loadBuildingsForWorker(workerId)
            let tasks = try await loadTasksForWorker(workerId)
            let progress = await calculateTaskProgress(for: workerId)
            
            await MainActor.run {
                self.dashboardData = DashboardData(
                    workerId: workerId,
                    assignedBuildings: buildings,
                    todaysTasks: tasks,
                    taskProgress: progress,
                    lastUpdated: Date()
                )
                
                self.lastRefresh = Date()
                self.isLoading = false
            }
            
        } catch {
            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
        }
    }
    
    func refreshDashboard() async {
        guard let currentData = dashboardData else { return }
        await loadDashboardData(for: currentData.workerId)
    }
    
    func updateTaskCompletion(_ taskId: String, buildingId: String) async {
        guard let workerId = dashboardData?.workerId else { return }
        
        do {
            let evidence = WDITaskEvidence(
                photos: [Data](),
                timestamp: Date(),
                location: CLLocation(latitude: 0, longitude: 0),
                notes: String?.none
            )
            
            try await taskService.completeTask(
                taskId,
                workerId: workerId,
                buildingId: buildingId,
                evidence: evidence
            )
            
            await contextEngine.updateTaskCompletion(
                workerId: workerId,
                buildingId: buildingId,
                taskName: ""
            )
            
            await refreshDashboard()
            
        } catch {
            await MainActor.run {
                self.error = error
            }
        }
    }
    
    private func loadBuildingsForWorker(_ workerId: String) async throws -> [FrancoSphere.NamedCoordinate] {
        return try await workerService.getAssignedBuildings(workerId)
    }
    
    private func loadTasksForWorker(_ workerId: String) async throws -> [ContextualTask] {
        return try await taskService.getTasks(for: workerId, date: Date())
    }
    
    private func calculateTaskProgress(for workerId: String) async -> WDITaskProgress {
        do {
            let progress = try await taskService.getTaskProgress(for: workerId)
            return WDITaskProgress(
                completed: progress.completed,
                total: progress.total,
                remaining: progress.remaining,
                percentage: progress.percentage,
                overdueTasks: progress.overdueTasks
            )
        } catch {
            return WDITaskProgress(
                completed: 0,
                total: 0,
                remaining: 0,
                percentage: 0,
                overdueTasks: 0
            )
        }
    }
    
    func ensureOperationalDataLoaded() async {
        do {
            let hasImported = await checkIfDataImported()
            if hasImported {
                print("‚úÖ Operational data already loaded")
                return
            }
            
            print("üîÑ Loading operational data...")
            await MainActor.run {
                csvImportProgress = 0.1
            }
            
            let (imported, errors) = try await operationalManager.importRealWorldTasks()
            
            await MainActor.run {
                csvImportProgress = 1.0
            }
            
            print("‚úÖ Loaded \(imported) real tasks from operational data")
            
            if !errors.isEmpty {
                print("‚ö†Ô∏è Import errors: \(errors)")
            }
            
        } catch {
            print("‚ùå Failed to load operational data: \(error)")
            await MainActor.run {
                self.error = error
            }
        }
    }
    
    private func checkIfDataImported() async -> Bool {
        do {
            guard let workerId = NewAuthManager.shared.workerId, !workerId.isEmpty else {
                return false
            }
            
            let allTasks = try await loadTasksForWorker(workerId)
            
            let operationalTasks = allTasks.filter { task in
                !task.assignedWorkerName.isEmpty
            }
            
            let hasMinimumTasks = allTasks.count >= 20
            let hasOperationalPattern = operationalTasks.count > 0
            
            return hasMinimumTasks || hasOperationalPattern
            
        } catch {
            print("‚ùå Error checking operational data status: \(error)")
            return false
        }
    }
    
    private func setupReactiveBindings() {
        contextEngine.objectWillChange
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                Task {
                    await self?.refreshDashboard()
                }
            }
            .store(in: &cancellables)
    }
    
    func startBackgroundUpdates() {
        refreshTimer = Timer.scheduledTimer(withTimeInterval: 300, repeats: true) { _ in
            Task {
                await self.refreshDashboard()
            }
        }
    }
    
    func stopBackgroundUpdates() {
        refreshTimer?.invalidate()
        refreshTimer = nil
    }
    
    deinit {
        refreshTimer?.invalidate()
        cancellables.removeAll()
    }
}

// MARK: - Supporting Types (Unique names to avoid conflicts)

struct DashboardData {
    let workerId: String
    let assignedBuildings: [FrancoSphere.NamedCoordinate]
    let todaysTasks: [ContextualTask]
    let taskProgress: WDITaskProgress
    let lastUpdated: Date
}

struct WDITaskProgress {
    let completed: Int
    let total: Int
    let remaining: Int
    let percentage: Double
    let overdueTasks: Int
}

struct WDITaskEvidence {
    let photos: [Data]
    let timestamp: Date
    let location: CLLocation?
    let notes: String?
}

extension WorkerDashboardIntegration {
    
    static func initialize() async {
        await shared.ensureOperationalDataLoaded()
    }
    
    static func loadForWorker(_ workerId: String) async -> WorkerDashboardIntegration {
        await shared.loadDashboardData(for: workerId)
        shared.startBackgroundUpdates()
        return shared
    }
}
INNER_EOF

echo "   ‚úÖ WorkerDashboardIntegration.swift fixed (final version)"

# Step 5: Fix Models/FrancoSphereModels.swift - Remove duplicate Worker declaration
echo "üîß Step 5: Fixing FrancoSphereModels.swift duplicate Worker..."

if [ -f "Models/FrancoSphereModels.swift" ]; then
    # Create backup
    cp "Models/FrancoSphereModels.swift" "Models/FrancoSphereModels.swift.backup"
    
    # Remove duplicate Worker struct (keep the first one, remove around line 2160)
    sed -i '' '2150,2200{/struct Worker/,/^}/d;}' "Models/FrancoSphereModels.swift"
    
    # Fix property visibility issues by making internal types public
    sed -i '' 's/public var.*: WorkerShift/public var currentShift: WorkerShiftPublic/g' "Models/FrancoSphereModels.swift"
    sed -i '' 's/public init.*WorkerShift/public init(currentShift: WorkerShiftPublic)/g' "Models/FrancoSphereModels.swift"
    
    echo "   ‚úÖ Fixed duplicate Worker declaration and visibility issues"
fi

# Step 6: Update all WorkerManager references to WorkerService
echo "üîÑ Step 6: Updating WorkerManager references to WorkerService..."

find . -name "*.swift" -type f -exec grep -l "WorkerManager" {} \; | while read file; do
    echo "   üìù Updating $file"
    sed -i '' 's/WorkerManager\.shared/WorkerService.shared/g' "$file"
    sed -i '' 's/WorkerManager(/WorkerService(/g' "$file"
    sed -i '' 's/: WorkerManager/: WorkerService/g' "$file"
done

echo "   ‚úÖ All WorkerManager references updated to WorkerService"

# Step 7: Add missing imports where needed
echo "üì• Step 7: Adding missing imports..."

# Add Foundation import to files that use MaintenanceTask
find . -name "*.swift" -type f -exec grep -l "MaintenanceTask" {} \; | while read file; do
    if ! grep -q "import Foundation" "$file"; then
        sed -i '' '1i\
import Foundation
' "$file"
        echo "   üìù Added Foundation import to $file"
    fi
done

echo "   ‚úÖ Missing imports added"

# Step 8: Test compilation
echo "üî® Step 8: Testing compilation..."

BUILD_OUTPUT=$(xcodebuild clean build -project FrancoSphere.xcodeproj -scheme FrancoSphere -destination 'platform=iOS Simulator,name=iPhone 15' 2>&1)
ERROR_COUNT=$(echo "$BUILD_OUTPUT" | grep -c "error:" || echo "0")

echo ""
echo "üìä Build Results: $ERROR_COUNT errors"

if [ "$ERROR_COUNT" -eq 0 ]; then
    echo ""
    echo "üéâ SUCCESS: All missing type errors fixed!"
    echo "‚úÖ MaintenanceTask, TaskCategory, TaskUrgency, TaskRecurrence defined"
    echo "‚úÖ WeatherManager created"
    echo "‚úÖ TSTaskProgress conflicts resolved"
    echo "‚úÖ Worker redeclaration fixed"
    echo "‚úÖ WorkerManager references updated to WorkerService"
    echo "‚úÖ All imports added"
else
    echo ""
    echo "‚ö†Ô∏è Still has $ERROR_COUNT compilation errors"
    echo "Top 10 remaining errors:"
    echo "$BUILD_OUTPUT" | grep "error:" | head -10
    
    # Show specific file error counts
    echo ""
    echo "üìä Error breakdown by file:"
    echo "$BUILD_OUTPUT" | grep "error:" | cut -d: -f1 | sort | uniq -c | sort -nr | head -5
fi

echo ""
echo "üîß Type definition fix complete!"
echo "üìÅ New files created:"
echo "   - Models/TaskTypes.swift (MaintenanceTask, TaskCategory, TaskUrgency, TaskRecurrence)"
echo "   - Managers/WeatherManager.swift"
echo "üìÅ Files fixed:"
echo "   - Services/WorkerDashboardIntegration.swift"
echo "   - Models/FrancoSphereModels.swift"
echo "   - All files with WorkerManager references"
